---
id: minimum-cost-tree-from-leaf-values
title: 1130.叶值的最小代价生成树
---
给你一个正整数数组 <code>arr</code>，考虑所有满足以下条件的二叉树：


- 每个节点都有 0 个或是 2 个子节点。
- 数组 <code>arr</code> 中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。）
- 每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。

在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。

 

**示例：**


<pre><strong>输入：</strong>arr = [6,2,4]<br/><strong>输出：</strong>32<br/><strong>解释：</strong><br/>有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。<br/><br/>    24            24<br/>   /  \          /  \<br/>  12   4        6    8<br/> /  \               / \<br/>6    2             2   4</pre>

 

**提示：**


- <code>2 &lt;= arr.length &lt;= 40</code>
- <code>1 &lt;= arr[i] &lt;= 15</code>
- 答案保证是一个 32 位带符号整数，即小于 <code>2^31</code>。
